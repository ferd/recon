
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <link href='http://fonts.googleapis.com/css?family=Titillium+Web:400,300italic,600italic,700,600,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,700italic,400italic' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="screen.css" media="screen, projection" />
    <title>Recon Library</title>
  </head>
  <body>
    <header>
        <h1>Recon</h1>
        <nav>
          <ul>
<li><a href="index.html">index</a><li><a href="recon.html">recon</a><li><a href="recon_alloc.html">recon_alloc</a><li><a href="recon_lib.html">recon_lib</a><li><a href="recon_trace.html">recon_trace</a>
          </ul>
        </nav>
    </header>
    <article>
    <h2>Module recon_trace</h2>
<ul class="index"><li><a href="#description">Description</a></li><li><a href="#types">Data Types</a></li><li><a href="#index">Function Index</a></li><li><a href="#functions">Function Details</a></li></ul>
   <code>recon_trace</code> is a module that handles tracing in a safe manner for single   
Erlang nodes, currently for function calls only.

<p><strong>Authors:</strong> Fred Hebert (<a href="mailto:mononcqc@ferd.ca"><code>mononcqc@ferd.ca</code></a>) [<em>web site:</em> <code><a href="http://ferd.ca/" target="_top">http://ferd.ca/</a></code>].</p>

<h3><a name="description">Description</a></h3><p>
   <code>recon_trace</code> is a module that handles tracing in a safe manner for single   
Erlang nodes, currently for function calls only. Functionality includes:</p>
  
   <ul>
       <li>Nicer to use interface (arguably) than <code>dbg</code> or trace BIFs.</li>
       <li>Protection against dumb decisions (matching all calls on a node
           being traced, for example)</li>
       <li>Adding safe guards in terms of absolute trace count or
           rate-limitting</li>
       <li>Nicer formatting than default traces</li>
   </ul>
  
   <h4><a name="Tracing_Erlang_Code">Tracing Erlang Code</a></h4>
  
   <p>The Erlang Trace BIFs allow to trace any Erlang code at all. They work in   
two parts: pid specifications, and trace patterns.</p>
  
   <p>Pid specifications let you decide which processes to target. They can be
   specific pids, <code>all</code> pids, <code>existing</code> pids, or <code>new</code> pids (those not   
spawned at the time of the function call).</p>
  
   <p>The trace patterns represent functions. Functions can be specified in two
   parts: specifying the modules, functions, and arguments, and then with
   Erlang match specifications to add constraints to arguments (see
   <a href="#calls-3"><code>calls/3</code></a> for details).</p>
  
   <p>What defines whether you get traced or not is the intersection of both:</p>
  
   <pre>           _,--------,_      _,--------,_
        ,-'            `-,,-'            `-,
     ,-'              ,-'  '-,              `-,
    |   Matching    -'        '-   Matching    |
    |     Pids     |  Getting   |    Trace     |
    |              |   Traced   |  Patterns    |
    |               -,        ,-               |
     '-,              '-,  ,-'              ,-'
        '-,_          _,-''-,_          _,-'
            '--------'        '--------'</pre>
  
   <p>If either the pid specification excludes a process or a trace pattern   
excludes a given call, no trace will be received.</p>
  
   <h4><a name="Example_Session">Example Session</a></h4>
  
   <p>First let's trace the <code>queue:new</code> functions in any process:</p>
  
   <pre>   1&gt; recon_trace:calls({queue, new, '_'}, 1).
   1
   13:14:34.086078 &lt;0.44.0&gt; queue:new()
   Recon tracer rate limit tripped.</pre>
  
   <p>The limit was set to <code>1</code> trace message at most, and <code>recon</code> let us   
know when that limit was reached.</p>
  
   <p>Let's instead look for all the <code>queue:in/2</code> calls, to see what it is   
we're inserting in queues:</p>
  
   <pre>   2&gt; recon_trace:calls({queue, in, 2}, 1).
   1
   13:14:55.365157 &lt;0.44.0&gt; queue:in(a, {[],[]})
   Recon tracer rate limit tripped.</pre>
  
   <p>In order to see the content we want, we should change the trace patterns
   to use a <code>fun</code> that matches on all arguments in a list (<code>_</code>) and returns
   <code>return_trace()</code>. This last part will generate a second trace for each   
call that includes the return value:</p>
  
   <pre>   3&gt; recon_trace:calls({queue, in, fun(_) -&gt; return_trace() end}, 3).
   1
  
   13:15:27.655132 &lt;0.44.0&gt; queue:in(a, {[],[]})
  
   13:15:27.655467 &lt;0.44.0&gt; queue:in/2 --&gt; {[a],[]}
  
   13:15:27.757921 &lt;0.44.0&gt; queue:in(a, {[],[]})
   Recon tracer rate limit tripped.</pre>
  
   <p>Matching on argument lists can be done in a more complex manner:</p>
  
   <pre>   4&gt; recon_trace:calls(
   4&gt;   {queue, '_', fun([A,_]) when is_list(A); is_integer(A) andalso A &gt; 1 -&gt; return_trace() end},
   4&gt;   {10,100}
   4&gt; ).
   32
  
   13:24:21.324309 &lt;0.38.0&gt; queue:in(3, {[],[]})
  
   13:24:21.371473 &lt;0.38.0&gt; queue:in/2 --&gt; {[3],[]}
  
   13:25:14.694865 &lt;0.53.0&gt; queue:split(4, {[10,9,8,7],[1,2,3,4,5,6]})
  
   13:25:14.695194 &lt;0.53.0&gt; queue:split/2 --&gt; {{[4,3,2],[1]},{[10,9,8,7],[5,6]}}
  
   5&gt; recon_trace:clear().
   ok</pre>
  
   <p>Note that in the pattern above, no specific function (<code>'_'</code>) was
   matched against. Instead, the <code>fun</code> used restricted functions to those
   having two arguments, the first of which is either a list or an integer
   greater than <code>1</code>.</p>
  
   <p>The limit was also set using <code>{10,100}</code> instead of an integer, making the   
rate-limitting at 10 messages per 100 milliseconds, instead of an absolute   
value.</p>
  
   <p>Any tracing can be manually interrupted by calling <code>recon_trace:clear()</code>,   
or killing the shell process.</p>
  
   <p>Be aware that extremely broad patterns with lax rate-limitting (or very
   high absolute limits) may impact your node's stability in ways
   <code>recon_trace</code> cannot easily help you with.</p>
  
   <p>In doubt, start with the most restrictive tracing possible, with low   
limits, and progressively increase your scope.</p>
  
   <p>See <a href="#calls-3"><code>calls/3</code></a> for more details and tracing possibilities.</p>
  
   <h4><a name="Structure">Structure</a></h4>
  
   <p>This library is production-safe due to taking the following structure for   
tracing:</p>
  
   <pre>   [IO/Group leader] &lt;---------------------,
     |                                     |
   [shell] ---&gt; [tracer process] ----&gt; [formatter]</pre>
  
   <p>The tracer process receives trace messages from the node, and enforces   
limits in absolute terms or trace rates, before forwarding the messages   
to the formatter. This is done so the tracer can do as little work as   
possible and never block while building up a large mailbox.</p>
  
   <p>The tracer process is linked to the shell, and the formatter to the   
tracer process. The formatter also traps exits to be able to handle   
all received trace messages until the tracer termination, but will then   
shut down as soon as possible.</p>
  
   In case the operator is tracing from a remote shell which gets
   disconnected, the links between the shell and the tracer should make it
   so tracing is automatically turned off once you disconnect.
<h3><a name="types">Data Types</a></h3>

<h4 class="typedecl"><a name="type-args">args()</a></h4>
<p><code>args() = '_' | 0..255 | <a href="#type-matchspec">matchspec()</a> | <a href="#type-shellfun">shellfun()</a></code></p>


<h4 class="typedecl"><a name="type-fn">fn()</a></h4>
<p><code>fn() = '_' | atom()</code></p>


<h4 class="typedecl"><a name="type-matchspec">matchspec()</a></h4>
<p><code>matchspec() = [{[term()], [term()], [term()]}]</code></p>


<h4 class="typedecl"><a name="type-max">max()</a></h4>
<p><code>max() = <a href="#type-max_traces">max_traces()</a> | <a href="#type-max_rate">max_rate()</a></code></p>


<h4 class="typedecl"><a name="type-max_rate">max_rate()</a></h4>
<p><code>max_rate() = {<a href="#type-max_traces">max_traces()</a>, <a href="#type-millisecs">millisecs()</a>}</code></p>


<h4 class="typedecl"><a name="type-max_traces">max_traces()</a></h4>
<p><code>max_traces() = non_neg_integer()</code></p>


<h4 class="typedecl"><a name="type-mfa">mfa()</a></h4>
<p><code>mfa() = {<a href="#type-mod">mod()</a>, <a href="#type-fn">fn()</a>, <a href="#type-args">args()</a>}</code></p>


<h4 class="typedecl"><a name="type-millisecs">millisecs()</a></h4>
<p><code>millisecs() = non_neg_integer()</code></p>


<h4 class="typedecl"><a name="type-mod">mod()</a></h4>
<p><code>mod() = '_' | module()</code></p>


<h4 class="typedecl"><a name="type-num_matches">num_matches()</a></h4>
<p><code>num_matches() = non_neg_integer()</code></p>


<h4 class="typedecl"><a name="type-options">options()</a></h4>
<p><code>options() = [{pid, <a href="#type-pidspec">pidspec()</a> | [<a href="#type-pidspec">pidspec()</a>, ...]} | {timestamp, formatter | trace} | {args, args | arity} | {scope, global | local}]</code></p>


<h4 class="typedecl"><a name="type-pidspec">pidspec()</a></h4>
<p><code>pidspec() = all | existing | new | <a href="recon.html#type-pid_term">recon:pid_term()</a></code></p>


<h4 class="typedecl"><a name="type-shellfun">shellfun()</a></h4>
<p><code>shellfun() = fun((term()) -&gt; term())</code></p>


<h3><a name="index">Function Index</a></h3>
<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#calls-2">calls/2</a></td><td>Equivalent to <a href="#calls-3"><code>calls({Mod, Fun, Args}, Max, [])</code></a>.
</td></tr>
<tr><td valign="top"><a href="#calls-3">calls/3</a></td><td>Allows to set trace patterns and pid specifications to trace  
function calls.</td></tr>
<tr><td valign="top"><a href="#clear-0">clear/0</a></td><td>Stops all tracing at once.</td></tr>
</table>

<h3><a name="functions">Function Details</a></h3>

<h4 class="function"><a name="calls-2">calls/2</a></h4>
<div class="spec">
<p><code>calls(X1::mfa(), Max::<a href="#type-max">max()</a>) -&gt; <a href="#type-num_matches">num_matches()</a></code><br></p>
</div><p>Equivalent to <a href="#calls-3"><code>calls({Mod, Fun, Args}, Max, [])</code></a>.</p>


<h4 class="function"><a name="calls-3">calls/3</a></h4>
<div class="spec">
<p><code>calls(MFAs::mfa() | [mfa(), ...], Max::<a href="#type-max">max()</a>, Opts::<a href="#type-options">options()</a>) -&gt; <a href="#type-num_matches">num_matches()</a></code><br></p>
</div><p><p>Allows to set trace patterns and pid specifications to trace  
function calls.</p>
 
  <p>The basic calls take the trace patterns as tuples of the form
  <code>{Module, Function, Args}</code> where:</p>
 
  <ul>
   <li><code>Module</code> is any atom representing a module</li>
   <li><code>Function</code> is any atom representing a function, or the wildcard
       <code>'_'</code></li>
   <li><code>Args</code> is either the arity of a function (<code>0..255</code>), a wildcard
       pattern (<code>'_'</code>), a
       <a href="http://learnyousomeerlang.com/ets#you-have-been-selected">match specification</a>,
       or a function from a shell session that can be transformed into
       a match specification</li>
  </ul>
 
  <p>There is also an argument specifying either a maximal count (a number)
  of trace messages to be received, or a maximal frequency (<code>{Num, Millisecs}</code>).</p>
 
  <p>Here are examples of things to trace:</p>
 
  <ul>
   <li>All calls from the <code>queue</code> module, with 10 calls printed at most:
       <code>recon_trace:calls({queue, '_', '_'}, 10)</code></li>
   <li>All calls to <code>lists:seq(A,B)</code>, with 100 calls printed at most:
       <code>recon_trace:calls({lists, seq, 2}, 100)</code></li>
   <li>All calls to <code>lists:seq(A,B)</code>, with 100 calls per second at most:
       <code>recon_trace:calls({lists, seq, 2}, {100, 1000})</code></li>
   <li>All calls to <code>lists:seq(A,B,2)</code> (all sequences increasing by two)
       with 100 calls at most:
       <code>recon_trace:calls({lists, seq, fun([_,_,2]) -&gt; ok end}, 100)</code></li>
   <li>All calls to <code>iolist_to_binary/1</code> made with a binary as an argument
       already (kind of useless conversion!):
       <code>recon_trace:calls({erlang, iolist_to_binary, fun([X]) when is_binary(X) -&gt; ok end}, 10)</code></li>
   <li>Calls to the queue module only in a given process <code>Pid</code>, at a rate
       of 50 per second at most:
       <code>recon_trace:calls({queue, '_', '_'}, {50,1000}, [{pid, Pid}])</code></li>
   <li>Print the traces with the function arity instead of literal arguments:
       <code>recon_trace:calls(MFA, Max, [{args, arity}])</code></li>
   <li>Matching the <code>filter/2</code> functions of both <code>dict</code> and <code>lists</code> modules,
       across new processes only:
       <code>recon_trace:calls([{dict,filter,2},{lists,filter,2}], 10, [{pid, new]})</code></li>
   <li>Tracing the <code>handle_call/3</code> functions of a given module for all new processes,
       and those of an existing one registered with <code>gproc</code>:
       <code>recon_trace:calls({Mod,handle_call,3}, {10,100}, [{pid, [{via, gproc, Name}, new]}</code></li>
   <li>Show the result of a given function call:
       <code>recon_trace:calls({Mod,Fun,fun(_) -&gt; return_trace() end}, Max, Opts)</code>
       or
       <code>recon_trace:calls({Mod,Fun,[{'_', [], [{return_trace}]}]}, Max, Opts)</code>,
       the important bit being the <code>return_trace()</code> call or the
       <code>{return_trace}</code> match spec value.</li>
  </ul>
 
  <p>There's a few more combination possible, with multiple trace patterns per call, and more  
options:</p>
 
  <ul>
   <li><code>{pid, PidSpec}</code>: which processes to trace. Valid options is any of
       <code>all</code>, <code>new</code>, <code>existing</code>, or a process descriptor (<code>{A,B,C}</code>,
       <code>"&lt;A.B.C&gt;"</code>, an atom representing a name, <code>{global, Name}</code>,
       <code>{via, Registrar, Name}</code>, or a pid). It's also possible to specify
       more than one by putting them in a list.</li>
   <li><code>{timestamp, formatter | trace}</code>: by default, the formatter process
       adds timestamps to messages received. If accurate timestamps are
       required, it's possible to force the usage of timestamps within
       trace messages by adding the option <code>{timestamp, trace}</code>.</li>
   <li><code>{args, arity | args}</code>: whether to print arity in function calls
       or their (by default) literal representation.</li>
   <li><code>{scope, global | local}</code>: by default, only 'global' (fully qualified
       function calls) are traced, not calls made internally. To force tracing
       of local calls, pass in <code>{scope, local}</code>. This is useful whenever
       you want to track the changes of code in a process that isn't called
       with <code>Module:Fun(Args)</code>, but just <code>Fun(Args)</code>.</li>
  </ul>
 
  Also note that putting extremely large <code>Max</code> values (i.e. <code>99999999</code> or
  <code>{10000,1}</code>) will probably negate most of the safe-guarding this library
  does and be dangerous to your node. Similarly, tracing extremely large
  amounts of function calls (all of them, or all of <code>io</code> for example)
  can be risky if more trace messages are generated than any process on
  the node could ever handle, despite the precautions taken by this library.</p>

<h4 class="function"><a name="clear-0">clear/0</a></h4>
<div class="spec">
<p><code>clear() -&gt; ok</code><br></p>
</div><p>Stops all tracing at once.</p>

    </article>
  </body>
</html>
